/* rb.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "RB", lower_case_cprefix = "rb_")]
namespace RB {
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class BrowserSource : RB.Source, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		public unowned string get_paned_key ();
		public bool has_drop_support ();
		[NoWrapper]
		public virtual unowned string impl_get_paned_key ();
		[NoWrapper]
		public virtual bool impl_has_drop_support ();
		[NoWrapper]
		public virtual void impl_pack_paned (Gtk.Widget paned);
		[NoWrapper]
		public virtual void impl_show_entry_popup ();
		[NoAccessorMethod]
		public bool populate { get; set construct; }
		[NoAccessorMethod]
		public string sorting_key { owned get; construct; }
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class EntryView : Gtk.ScrolledWindow, Atk.Implementor, Gtk.Buildable {
		[CCode (has_construct_function = false)]
		public EntryView (RhythmDB.DB db, GLib.Object shell_player, string sort_key, bool is_drag_source, bool is_drag_dest);
		public void append_column (RB.EntryViewColumn coltype, bool always_visible);
		public void append_column_custom (Gtk.TreeViewColumn column, string title, string key, GLib.CompareDataFunc sort_func, void* data, GLib.DestroyNotify data_destroy);
		public void enable_drag_source (Gtk.TargetEntry[] targets);
		public unowned Gtk.TreeViewColumn get_column (RB.EntryViewColumn coltype);
		public bool get_entry_contained (RhythmDB.Entry entry);
		public bool get_entry_visible (RhythmDB.Entry entry);
		public unowned GLib.List get_selected_entries ();
		public void get_sorting_order (out unowned string column_name, int sort_order);
		public unowned string get_sorting_type ();
		public static unowned string get_time_date_column_sample ();
		public bool have_complete_selection ();
		public bool have_selection ();
		public void insert_column_custom (Gtk.TreeViewColumn column, string title, string key, GLib.CompareDataFunc sort_func, void* data, GLib.DestroyNotify data_destroy, int position);
		public void resort_model ();
		public void scroll_to_entry (RhythmDB.Entry entry);
		public void select_all ();
		public void select_entry (RhythmDB.Entry entry);
		public void select_none ();
		public void set_column_editable (RB.EntryViewColumn column, bool editable);
		public void set_columns_clickable (bool clickable);
		public void set_fixed_column_width (Gtk.TreeViewColumn column, Gtk.CellRenderer renderer, string strings);
		public void set_model (RhythmDB.QueryModel model);
		public void set_sorting_order (string column_name, int sort_order);
		public void set_sorting_type (string sorttype);
		public void set_state (RB.EntryViewState state);
		[NoAccessorMethod]
		public RhythmDB.DB db { owned get; construct; }
		[NoAccessorMethod]
		public bool is_drag_dest { get; construct; }
		[NoAccessorMethod]
		public bool is_drag_source { get; construct; }
		[NoAccessorMethod]
		public RhythmDB.QueryModel model { owned get; set; }
		[NoAccessorMethod]
		public int playing_state { get; set; }
		[NoAccessorMethod]
		public RB.ShellPlayer shell_player { owned get; construct; }
		[NoAccessorMethod]
		public string sort_key { owned get; set; }
		public virtual signal void entries_replaced ();
		public virtual signal void entry_activated (RhythmDB.Entry entry);
		public virtual signal void entry_added (RhythmDB.Entry entry);
		public virtual signal void entry_deleted (RhythmDB.Entry entry);
		public virtual signal void have_selection_changed (bool have_selection);
		public virtual signal void selection_changed ();
		public virtual signal void show_popup (bool over_entry);
		public virtual signal void sort_order_changed ();
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class LibrarySource : RB.BrowserSource, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		[CCode (type = "RBSource*", has_construct_function = false)]
		public LibrarySource (RB.Shell shell);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class PlayOrder : GLib.Object {
		[NoWrapper]
		public virtual void db_changed (RhythmDB.DB new_db);
		[NoWrapper]
		public virtual void db_entry_deleted (RhythmDB.Entry entry);
		[NoWrapper]
		public virtual void entry_added (RhythmDB.Entry entry);
		[NoWrapper]
		public virtual void entry_removed (RhythmDB.Entry entry);
		public unowned RhythmDB.DB get_db ();
		public virtual unowned RhythmDB.Entry get_next ();
		public unowned RB.ShellPlayer get_player ();
		public unowned RhythmDB.Entry get_playing_entry ();
		public virtual unowned RhythmDB.Entry get_previous ();
		public unowned RhythmDB.QueryModel get_query_model ();
		public unowned RB.Source get_source ();
		public virtual void go_next ();
		public virtual void go_previous ();
		public virtual bool has_next ();
		public virtual bool has_previous ();
		public bool model_not_empty ();
		public bool player_is_playing ();
		[NoWrapper]
		public virtual void playing_entry_changed (RhythmDB.Entry old_entry, RhythmDB.Entry new_entry);
		[NoWrapper]
		public virtual void playing_entry_removed (RhythmDB.Entry entry);
		public virtual void playing_source_changed (RB.Source source);
		public virtual void query_model_changed ();
		public void set_playing_entry (RhythmDB.Entry entry);
		public RB.ShellPlayer player { get; construct; }
		public RhythmDB.Entry playing_entry { get; set; }
		public virtual signal void have_next_previous_changed (bool have_next, bool have_previous);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class PlayQueueSource : RB.StaticPlaylistSource, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		[CCode (type = "RBSource*", has_construct_function = false)]
		public PlayQueueSource (RB.Shell shell);
		public void clear_queue ();
		public void sidebar_delete ();
		public void sidebar_song_info ();
		[NoAccessorMethod]
		public RB.EntryView sidebar { owned get; }
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class PlaylistManager : GLib.Object {
		[CCode (has_construct_function = false)]
		public PlaylistManager (RB.Shell shell, RB.SourceList sourcelist, string playlists_file);
		public bool add_to_playlist (string name, string uri) throws GLib.Error;
		public bool create_static_playlist (string name) throws GLib.Error;
		public bool delete_playlist (string name) throws GLib.Error;
		public static GLib.Quark error_quark ();
		public bool export_playlist (string name, string uri, bool m3u_format) throws GLib.Error;
		public bool get_playlist_names (string playlists) throws GLib.Error;
		public unowned GLib.List get_playlists ();
		public void load_playlists ();
		public bool parse_file (string uri) throws GLib.Error;
		[CCode (type = "RBSource*", has_construct_function = false)]
		public PlaylistManager.playlist (RB.PlaylistManager mgr, string suggested_name, bool automatic);
		[CCode (type = "RBSource*", has_construct_function = false)]
		public PlaylistManager.playlist_from_selection_data (RB.PlaylistManager mgr, Gtk.SelectionData data);
		public bool remove_from_playlist (string name, string uri) throws GLib.Error;
		public bool save_playlists (bool force);
		public void shutdown ();
		[NoAccessorMethod]
		public string playlists_file { owned get; set; }
		[NoAccessorMethod]
		public RB.Shell shell { owned get; set; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		[NoAccessorMethod]
		public RB.SourceList sourcelist { owned get; construct; }
		public virtual signal void load_finish ();
		public virtual signal void load_start ();
		public virtual signal void playlist_added (GLib.Object source);
		public virtual signal void playlist_created (GLib.Object source);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class PlaylistSource : RB.Source, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		public bool add_to_map (string location);
		[CCode (type = "RBSource*", has_construct_function = false)]
		public PlaylistSource.from_xml (RB.Shell shell, Xml.Node node);
		public unowned RhythmDB.DB get_db ();
		public unowned RhythmDB.QueryModel get_query_model ();
		[NoWrapper]
		public virtual void impl_mark_dirty ();
		[NoWrapper]
		public virtual void impl_save_contents_to_xml (Xml.Node node);
		[NoWrapper]
		public virtual void impl_show_entry_view_popup (RB.EntryView view, bool over_entry);
		public bool location_in_map (string location);
		public void mark_dirty ();
		public void save_playlist (string uri, RB.PlaylistExportType export_type);
		public void save_to_xml (Xml.Node parent_node);
		public void set_query_model (RhythmDB.QueryModel model);
		public void setup_entry_view (RB.EntryView entry_view);
		public RhythmDB.DB db { get; }
		[NoAccessorMethod]
		public bool dirty { get; }
		[NoAccessorMethod]
		public bool is_local { get; construct; }
		[NoAccessorMethod]
		public string sorting_name { owned get; set; }
	}
	[CCode (cheader_filename = "shell/rb-plugin.h")]
	public abstract class Plugin : GLib.Object {
		public abstract void activate (RB.Shell shell);
		public virtual unowned Gtk.Widget create_configure_dialog ();
		public abstract void deactivate (RB.Shell shell);
		public unowned string find_file (string file);
		public virtual bool is_configurable ();
		[NoAccessorMethod]
		public string name { owned get; set; }
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class RemovableMediaManager : GLib.Object {
		[CCode (has_construct_function = false)]
		public RemovableMediaManager (RB.Shell shell);
		public void scan ();
		[NoAccessorMethod]
		public bool scanned { get; }
		[NoAccessorMethod]
		public RB.Shell shell { owned get; set; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		public virtual signal unowned RB.Source create_source_device (GLib.Object device);
		public virtual signal unowned RB.Source create_source_volume (GLib.Volume volume);
		public virtual signal void medium_added (GLib.Object source);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class Shell : GLib.Object {
		[CCode (has_construct_function = false)]
		public Shell (bool no_registration, bool no_update, bool dry_run, string rhythmdb, string playlists);
		public bool add_to_queue (string uri) throws GLib.Error;
		public bool add_uri (string uri, string title, string genre) throws GLib.Error;
		public void add_widget (Gtk.Widget widget, RB.ShellUILocation location, bool expand, bool fill);
		public void append_source (RB.Source source, RB.Source? parent);
		public bool clear_queue () throws GLib.Error;
		public bool do_notify (bool requested) throws GLib.Error;
		public static GLib.Quark error_quark ();
		public bool get_party_mode ();
		public unowned GLib.Object get_player ();
		public unowned string get_player_path ();
		public unowned GLib.Object get_playlist_manager ();
		public unowned string get_playlist_manager_path ();
		public bool get_song_properties (string uri, GLib.HashTable properties) throws GLib.Error;
		public unowned RB.Source get_source_by_entry_type (RhythmDB.EntryType type);
		public unowned GLib.Object get_ui_manager ();
		public unowned RB.Source guess_source_for_uri (string uri);
		public bool load_uri (string uri, bool play) throws GLib.Error;
		public void notebook_set_page (Gtk.Widget widget);
		public bool present (uint32 timestamp) throws GLib.Error;
		public bool quit () throws GLib.Error;
		public void register_entry_type_for_source (RB.Source source, RhythmDB.EntryType type);
		public bool remove_from_queue (string uri) throws GLib.Error;
		public void remove_widget (Gtk.Widget widget, RB.ShellUILocation location);
		public bool set_song_property (string uri, string propname, GLib.Value value) throws GLib.Error;
		public void toggle_visibility ();
		[NoAccessorMethod]
		public RB.ShellClipboard clipboard { owned get; }
		[NoAccessorMethod]
		public RhythmDB.DB db { owned get; }
		[NoAccessorMethod]
		public bool dry_run { get; construct; }
		[NoAccessorMethod]
		public RB.LibrarySource library_source { owned get; }
		[NoAccessorMethod]
		public bool no_registration { get; construct; }
		[NoAccessorMethod]
		public bool no_update { get; construct; }
		public RB.PlaylistManager playlist_manager { get; }
		[NoAccessorMethod]
		public string playlists_file { owned get; construct; }
		[NoAccessorMethod]
		public RB.ShellPreferences prefs { owned get; }
		[NoAccessorMethod]
		public RB.PlayQueueSource queue_source { owned get; }
		[NoAccessorMethod]
		public RB.RemovableMediaManager removable_media_manager { owned get; }
		[NoAccessorMethod]
		public string rhythmdb_file { owned get; construct; }
		[NoAccessorMethod]
		public RB.Source selected_source { owned get; }
		[NoAccessorMethod]
		public RB.ShellPlayer shell_player { owned get; }
		[NoAccessorMethod]
		public RB.SourceHeader source_header { owned get; }
		[NoAccessorMethod]
		public RB.SourceList sourcelist { owned get; }
		[NoAccessorMethod]
		public RB.SourceListModel sourcelist_model { owned get; }
		[NoAccessorMethod]
		public RB.TrackTransferQueue track_transfer_queue { owned get; }
		public Gtk.UIManager ui_manager { get; }
		[NoAccessorMethod]
		public bool visibility { get; set; }
		[NoAccessorMethod]
		public Gtk.Window window { owned get; }
		public virtual signal void create_song_info (RB.SongInfo song_info, bool multi);
		public virtual signal void notify_custom (uint p0, string p1, string p2, Gdk.Pixbuf p3, bool p4);
		public virtual signal void notify_playing_entry (bool p0);
		public virtual signal void removable_media_scan_finished ();
		public virtual signal void visibility_changed (bool visible);
		public virtual signal bool visibility_changing (bool initial, bool visible);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class ShellClipboard : GLib.Object {
		[CCode (has_construct_function = false)]
		public ShellClipboard (Gtk.ActionGroup actiongroup, Gtk.UIManager ui_mgr, RhythmDB.DB db);
		public void set_source (RB.Source source);
		[NoAccessorMethod]
		public Gtk.ActionGroup action_group { owned get; construct; }
		[NoAccessorMethod]
		public RhythmDB.DB db { owned get; construct; }
		[NoAccessorMethod]
		public RB.PlaylistManager playlist_manager { owned get; set; }
		[NoAccessorMethod]
		public RB.PlaylistSource queue_source { owned get; set; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		[NoAccessorMethod]
		public Gtk.UIManager ui_manager { owned get; construct; }
	}
	[CCode (cheader_filename = "shell/rb-shell-player.h")]
	public class ShellPlayer : Gtk.HBox, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		[CCode (has_construct_function = false)]
		public ShellPlayer (RhythmDB.DB db, Gtk.UIManager mgr, Gtk.ActionGroup actiongroup);
		public void add_play_order (string name, string description, GLib.Type order_type, bool hidden);
		public bool do_next () throws GLib.Error;
		public bool do_previous () throws GLib.Error;
		public static GLib.Quark error_quark ();
		public unowned RB.Source get_active_source ();
		public bool get_mute (bool mute) throws GLib.Error;
		public bool get_playback_state (bool shuffle, bool repeat);
		public bool get_playing (bool playing) throws GLib.Error;
		public unowned RhythmDB.Entry get_playing_entry ();
		public bool get_playing_path (string path) throws GLib.Error;
		public long get_playing_song_duration ();
		public unowned RB.Source get_playing_source ();
		public bool get_playing_time (uint time) throws GLib.Error;
		public unowned string get_playing_time_string ();
		public bool get_volume (double volume) throws GLib.Error;
		public void jump_to_current ();
		public bool pause () throws GLib.Error;
		public bool play () throws GLib.Error;
		public void play_entry (RhythmDB.Entry entry, RB.Source source);
		public bool playpause (bool unused) throws GLib.Error;
		public void remove_play_order (string name);
		public void seek (long offset);
		public bool set_mute (bool mute) throws GLib.Error;
		public void set_playback_state (bool shuffle, bool repeat);
		public void set_playing_source (RB.Source source);
		public bool set_playing_time (uint time) throws GLib.Error;
		public void set_selected_source (RB.Source source);
		public bool set_volume (double volume) throws GLib.Error;
		public bool set_volume_relative (double delta) throws GLib.Error;
		public void stop ();
		public void toggle_mute ();
		[NoAccessorMethod]
		public Gtk.ActionGroup action_group { owned get; construct; }
		[NoAccessorMethod]
		public RhythmDB.DB db { owned get; construct; }
		[NoAccessorMethod]
		public string play_order { owned get; }
		[NoAccessorMethod]
		public GLib.Object player { owned get; }
		public bool playing { get; }
		[NoAccessorMethod]
		public bool playing_from_queue { get; }
		[NoAccessorMethod]
		public bool queue_only { get; set; }
		[NoAccessorMethod]
		public RB.PlaylistSource queue_source { owned get; set; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		[NoAccessorMethod]
		public RB.Statusbar statusbar { owned get; set; }
		[NoAccessorMethod]
		public Gtk.UIManager ui_manager { owned get; construct; }
		public float volume { get; set; }
		public virtual signal void elapsed_changed (uint elapsed);
		public virtual signal void elapsed_nano_changed (int64 elapsed);
		public virtual signal bool missing_plugins (string[] p0, string[] p1, GLib.Closure p2);
		public virtual signal void playing_changed (bool playing);
		public virtual signal void playing_song_changed (RhythmDB.Entry entry);
		public virtual signal void playing_song_property_changed (string uri, string property, GLib.Value old, GLib.Value newValue);
		public virtual signal void playing_source_changed (RB.Source source);
		public virtual signal void playing_uri_changed (string uri);
		public virtual signal void window_title_changed (string window_title);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class ShellPreferences : Gtk.Dialog, Atk.Implementor, Gtk.Buildable {
		[CCode (type = "GtkWidget*", has_construct_function = false)]
		public ShellPreferences (GLib.List views);
		public void append_page (string name, Gtk.Widget widget);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class SongInfo : Gtk.Dialog, Atk.Implementor, Gtk.Buildable {
		[CCode (type = "GtkWidget*", has_construct_function = false)]
		public SongInfo (RB.Source source, RB.EntryView entry_view);
		public uint append_page (string title, Gtk.Widget page);
		[NoAccessorMethod]
		public RhythmDB.Entry current_entry { owned get; }
		[NoAccessorMethod]
		public RB.EntryView entry_view { owned get; construct; }
		[NoAccessorMethod]
		public GLib.ValueArray selected_entries { owned get; }
		[NoAccessorMethod]
		public RB.Source source { owned get; construct; }
		public virtual signal void post_metadata_change (RhythmDB.Entry entry);
		public virtual signal void pre_metadata_change (RhythmDB.Entry entry);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class Source : Gtk.HBox, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		public void activate ();
		public void add_to_queue (RB.Source queue);
		public bool add_uri (string uri, string title, string genre);
		[NoWrapper]
		public virtual void artistalbum_changed ();
		public void browser_toggled (bool enabled);
		public bool can_add_to_queue ();
		public bool can_browse ();
		public bool can_copy ();
		public bool can_cut ();
		public bool can_delete ();
		public bool can_move_to_trash ();
		public bool can_paste ();
		public bool can_pause ();
		public bool can_rename ();
		public bool can_show_properties ();
		public unowned GLib.List copy ();
		public unowned GLib.List cut ();
		public void deactivate ();
		public void @delete ();
		public void delete_thyself ();
		public unowned GLib.List gather_selected_properties (RhythmDB.PropType prop);
		public unowned string get_browser_key ();
		public unowned Gtk.Widget get_config_widget (RB.ShellPreferences prefs);
		public unowned string get_delete_action ();
		public unowned RB.EntryView get_entry_view ();
		public unowned GLib.List get_property_views ();
		public unowned GLib.List get_search_actions ();
		public void get_status (out unowned string text, out unowned string progress_text, float progress);
		public unowned GLib.List get_ui_actions ();
		public RB.SourceEOFType handle_eos ();
		[NoWrapper]
		public virtual void impl_activate ();
		[NoWrapper]
		public virtual void impl_add_to_queue (RB.Source queue);
		[NoWrapper]
		public virtual bool impl_add_uri (string uri, string title, string genre);
		[NoWrapper]
		public virtual void impl_browser_toggled (bool enabled);
		[NoWrapper]
		public virtual bool impl_can_add_to_queue ();
		[NoWrapper]
		public virtual bool impl_can_browse ();
		[NoWrapper]
		public virtual bool impl_can_copy ();
		[NoWrapper]
		public virtual bool impl_can_cut ();
		[NoWrapper]
		public virtual bool impl_can_delete ();
		[NoWrapper]
		public virtual bool impl_can_move_to_trash ();
		[NoWrapper]
		public virtual bool impl_can_paste ();
		[NoWrapper]
		public virtual bool impl_can_pause ();
		[NoWrapper]
		public virtual bool impl_can_rename ();
		[NoWrapper]
		public virtual unowned GLib.List impl_copy ();
		[NoWrapper]
		public virtual unowned GLib.List impl_cut ();
		[NoWrapper]
		public virtual void impl_deactivate ();
		[NoWrapper]
		public virtual void impl_delete ();
		[NoWrapper]
		public virtual void impl_delete_thyself ();
		[NoWrapper]
		public virtual unowned string impl_get_browser_key ();
		[NoWrapper]
		public virtual unowned Gtk.Widget impl_get_config_widget (RB.ShellPreferences prefs);
		[NoWrapper]
		public virtual unowned string impl_get_delete_action ();
		[NoWrapper]
		public virtual unowned RB.EntryView impl_get_entry_view ();
		[NoWrapper]
		public virtual unowned GLib.List impl_get_property_views ();
		[NoWrapper]
		public virtual unowned GLib.List impl_get_search_actions ();
		[NoWrapper]
		public virtual void impl_get_status (out unowned string text, out unowned string progress_text, float progress);
		[NoWrapper]
		public virtual unowned GLib.List impl_get_ui_actions ();
		[NoWrapper]
		public virtual RB.SourceEOFType impl_handle_eos ();
		[NoWrapper]
		public virtual bool impl_have_url ();
		[NoWrapper]
		public virtual void impl_move_to_trash ();
		[NoWrapper]
		public virtual void impl_paste (GLib.List entries);
		[NoWrapper]
		public virtual bool impl_receive_drag (Gtk.SelectionData data);
		[NoWrapper]
		public virtual void impl_reset_filters ();
		[NoWrapper]
		public virtual void impl_search (RB.SourceSearch search, string cur_text, string new_text);
		[NoWrapper]
		public virtual bool impl_show_popup ();
		[NoWrapper]
		public virtual void impl_song_properties ();
		[NoWrapper]
		public virtual bool impl_try_playlist ();
		[NoWrapper]
		public virtual bool impl_uri_is_source (string uri);
		[NoWrapper]
		public virtual uint impl_want_uri (string uri);
		public void move_to_trash ();
		public void notify_filter_changed ();
		public void notify_status_changed ();
		public void paste (GLib.List entries);
		public bool receive_drag (Gtk.SelectionData data);
		public void reset_filters ();
		public void search (RB.SourceSearch search, string cur_text, string new_text);
		public void set_hidden_when_empty (bool hidden);
		public void set_pixbuf (Gdk.Pixbuf pixbuf);
		public bool show_popup ();
		public void song_properties ();
		public bool try_playlist ();
		public void update_play_statistics (RhythmDB.DB db, RhythmDB.Entry entry);
		public bool uri_is_source (string uri);
		public uint want_uri (string uri);
		[NoAccessorMethod]
		public RhythmDB.QueryModel base_query_model { owned get; }
		[NoAccessorMethod]
		public RhythmDB.EntryType entry_type { owned get; construct; }
		[NoAccessorMethod]
		public bool hidden_when_empty { get; set; }
		[NoAccessorMethod]
		public Gdk.Pixbuf icon { owned get; set; }
		[NoAccessorMethod]
		public string name { owned get; set; }
		[NoAccessorMethod]
		public RB.PlayOrder play_order { owned get; }
		[NoAccessorMethod]
		public RB.Plugin plugin { owned get; set construct; }
		[NoAccessorMethod]
		public RhythmDB.QueryModel query_model { owned get; set; }
		[NoAccessorMethod]
		public RB.SourceSearchType search_type { get; set construct; }
		[NoAccessorMethod]
		public RB.Shell shell { owned get; construct; }
		[NoAccessorMethod]
		public RB.SourceGroup source_group { owned get; construct; }
		[NoAccessorMethod]
		public Gtk.UIManager ui_manager { owned get; }
		[NoAccessorMethod]
		public bool visibility { get; set; }
		public virtual signal void deleted ();
		public virtual signal void filter_changed ();
		public virtual signal void status_changed ();
	}
	[Compact]
	[CCode (type_id = "RB_TYPE_SOURCE_GROUP", cheader_filename = "sources/rb-source-group.h")]
	public class SourceGroup {
		public RB.SourceGroupCategory category;
		public weak string display_name;
		public weak string name;
		public static unowned RB.SourceGroup devices_get_type ();
		public static unowned RB.SourceGroup get_by_name (string name);
		public static void init ();
		public static unowned RB.SourceGroup library_get_type ();
		public static unowned RB.SourceGroup playlists_get_type ();
		public static unowned RB.SourceGroup register (string name, string display_name, RB.SourceGroupCategory category);
		public static unowned RB.SourceGroup shared_get_type ();
		public static unowned RB.SourceGroup stores_get_type ();
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class SourceHeader : Gtk.Table, Atk.Implementor, Gtk.Buildable {
		[CCode (has_construct_function = false)]
		public SourceHeader (Gtk.UIManager mgr, Gtk.ActionGroup actiongroup);
		public void clear_search ();
		public void focus_search_box ();
		public void set_source (RB.Source source);
		public void sync_control_state ();
		[NoAccessorMethod]
		public Gtk.ActionGroup action_group { owned get; construct; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		[NoAccessorMethod]
		public Gtk.UIManager ui_manager { owned get; construct; }
		public virtual signal unowned GLib.ValueArray get_search_actions (RB.Source p0);
		public virtual signal void refresh_search_bar ();
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class SourceList : Gtk.ScrolledWindow, Atk.Implementor, Gtk.Buildable {
		[CCode (cname = "rb_sourcelist_new", type = "GtkWidget*", has_construct_function = false)]
		public SourceList (RB.Shell shell);
		[CCode (cname = "rb_sourcelist_append")]
		public void append (RB.Source source, RB.Source parent);
		[CCode (cname = "rb_sourcelist_edit_source_name")]
		public void edit_source_name (RB.Source source);
		[CCode (cname = "rb_sourcelist_remove")]
		public void remove (RB.Source source);
		[CCode (cname = "rb_sourcelist_select")]
		public void select (RB.Source source);
		[CCode (cname = "rb_sourcelist_set_playing_source")]
		public void set_playing_source (RB.Source source);
		[NoAccessorMethod]
		public Gtk.TreeModel model { owned get; }
		[NoAccessorMethod]
		public RB.Shell shell { owned get; construct; }
		public virtual signal void drop_received (void* target, void* data);
		public virtual signal void selected (GLib.Object source);
		public virtual signal bool show_popup (RB.Source target);
		public virtual signal void source_activated (GLib.Object target);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class SourceListModel : Gtk.TreeModelFilter, Gtk.TreeModel, Gtk.TreeDragSource, RB.RbTreeDragSource, RB.RbTreeDragDest {
		[CCode (cname = "rb_sourcelist_model_new", type = "GtkTreeModel*", has_construct_function = false)]
		public SourceListModel ();
		[CCode (cname = "rb_sourcelist_model_set_dnd_targets")]
		public void set_dnd_targets (Gtk.TreeView treeview);
		public virtual signal void drop_received (RB.Source target, int pos, void* data);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class SourceSearch : GLib.Object {
		public void action_attach (GLib.Object action);
		public virtual unowned RhythmDB.Query create_query (RhythmDB.DB db, string search_text);
		public static unowned RB.SourceSearch get_from_action (GLib.Object action);
		public virtual bool is_subset (string current, string next);
	}
	[CCode (cheader_filename = "sources/rb-static-playlist-source.h")]
	public class StaticPlaylistSource : RB.PlaylistSource, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		[CCode (type = "RBSource*", has_construct_function = false)]
		public StaticPlaylistSource (RB.Shell shell, string name, string sorting_name, bool local, RhythmDB.EntryType entry_type);
		public void add_entry (RhythmDB.Entry entry, int index);
		public void add_location (string location, int index);
		public void add_locations (GLib.List locations);
		[CCode (type = "RBSource*", has_construct_function = false)]
		public StaticPlaylistSource.from_xml (RB.Shell shell, Xml.Node node);
		public void load_from_xml (Xml.Node node);
		public void move_entry (RhythmDB.Entry entry, int index);
		public void remove_entry (RhythmDB.Entry entry);
		public void remove_location (string location);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class Statusbar : Gtk.Statusbar, Atk.Implementor, Gtk.Buildable, Gtk.Orientable {
		[CCode (has_construct_function = false)]
		public Statusbar (RhythmDB.DB db, Gtk.UIManager ui_manager, RB.TrackTransferQueue transfer_queue);
		public void set_source (RB.Source source);
		[NoAccessorMethod]
		public RhythmDB.DB db { owned get; set; }
		[NoAccessorMethod]
		public RB.Source source { owned get; set; }
		[NoAccessorMethod]
		public RB.TrackTransferQueue transfer_queue { owned get; construct; }
		[NoAccessorMethod]
		public Gtk.UIManager ui_manager { owned get; construct; }
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class TrackTransferBatch : GLib.Object {
		[CCode (has_construct_function = false)]
		public TrackTransferBatch (GLib.List media_type_list, out unowned string media_types, RB.Source source, RB.Source destination);
		public void add (RhythmDB.Entry entry);
		public void cancel ();
		public uint check_media_types ();
		[NoAccessorMethod]
		public RB.Source destination { owned get; construct; }
		[NoAccessorMethod]
		public int done_entries { get; }
		public void* media_types { construct; }
		[NoAccessorMethod]
		[CCode (array_length = false, array_null_terminated = true)]
		public string[] media_types_strv { owned get; construct; }
		[NoAccessorMethod]
		public double progress { get; }
		[NoAccessorMethod]
		public RB.Source source { owned get; construct; }
		[NoAccessorMethod]
		public int total_entries { get; }
		public virtual signal void cancelled ();
		public virtual signal void complete ();
		public virtual signal unowned string get_dest_uri (RhythmDB.Entry entry, string mediatype, string extension);
		public virtual signal bool overwrite_prompt (GLib.File dest_file);
		public virtual signal void started ();
		public virtual signal void track_done (RhythmDB.Entry entry, string dest, uint64 dest_size, string error, void* p4);
		public virtual signal void track_progress (RhythmDB.Entry entry, string dest, int done, int total, double fraction);
		public virtual signal void track_started (RhythmDB.Entry entry, string dest);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public class TrackTransferQueue : GLib.Object {
		[CCode (has_construct_function = false)]
		public TrackTransferQueue (RB.Shell shell);
		public void cancel_batch (RB.TrackTransferBatch batch);
		public unowned GLib.List find_batch_by_source (RB.Source source);
		public bool get_status (out unowned string text, out unowned string progress_text, float progress, int time_left);
		public void start_batch (RB.TrackTransferBatch batch);
		[NoAccessorMethod]
		public RB.TrackTransferBatch batch { owned get; }
		[NoAccessorMethod]
		public RB.Shell shell { owned get; construct; }
		public virtual signal bool missing_plugins (string[] p0, string[] p1, GLib.Closure p2);
		public virtual signal void transfer_progress (int done, int total, double fraction, int time_left);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public interface RbTreeDragDest {
		[CCode (cname = "rb_tree_drag_dest_drag_data_received")]
		public static bool drag_data_received (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest, Gtk.TreeViewDropPosition pos, Gtk.SelectionData selection_data);
		[NoWrapper]
		public abstract bool rb_drag_data_received (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest, Gtk.TreeViewDropPosition pos, Gtk.SelectionData selection_data);
		[NoWrapper]
		public abstract Gdk.Atom rb_get_drag_target (RB.RbTreeDragDest drag_dest, Gtk.Widget widget, Gdk.DragContext context, Gtk.TreePath dest_path, Gtk.TargetList target_list);
		[NoWrapper]
		public abstract bool rb_row_drop_position (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest_path, GLib.List targets, Gtk.TreeViewDropPosition pos);
		[NoWrapper]
		public abstract bool rb_row_drop_possible (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest_path, Gtk.TreeViewDropPosition pos, Gtk.SelectionData selection_data);
		[CCode (cname = "rb_tree_drag_dest_row_drop_position")]
		public static bool row_drop_position (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest_path, GLib.List targets, Gtk.TreeViewDropPosition pos);
		[CCode (cname = "rb_tree_drag_dest_row_drop_possible")]
		public static bool row_drop_possible (RB.RbTreeDragDest drag_dest, Gtk.TreePath dest_path, Gtk.TreeViewDropPosition pos, Gtk.SelectionData selection_data);
	}
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public interface RbTreeDragSource {
		[CCode (cname = "rb_tree_drag_source_drag_data_delete")]
		public static bool drag_data_delete (RB.RbTreeDragSource drag_source, GLib.List path_list);
		[CCode (cname = "rb_tree_drag_source_drag_data_get")]
		public static bool drag_data_get (RB.RbTreeDragSource drag_source, GLib.List path_list, Gtk.SelectionData selection_data);
		[NoWrapper]
		public abstract bool rb_drag_data_delete (RB.RbTreeDragSource drag_source, GLib.List path_list);
		[NoWrapper]
		public abstract bool rb_drag_data_get (RB.RbTreeDragSource drag_source, GLib.List path_list, Gtk.SelectionData selection_data);
		[NoWrapper]
		public abstract bool rb_row_draggable (RB.RbTreeDragSource drag_source, GLib.List path_list);
		[CCode (cname = "rb_tree_drag_source_row_draggable")]
		public static bool row_draggable (RB.RbTreeDragSource drag_source, GLib.List path_list);
	}
	[CCode (cprefix = "RB_ENTRY_VIEW_COL_", cheader_filename = "shell/rb-shell.h")]
	public enum EntryViewColumn {
		TRACK_NUMBER,
		TITLE,
		ARTIST,
		ALBUM,
		GENRE,
		COMMENT,
		DURATION,
		QUALITY,
		RATING,
		PLAY_COUNT,
		YEAR,
		LAST_PLAYED,
		FIRST_SEEN,
		LAST_SEEN,
		LOCATION,
		ERROR
	}
	[CCode (cprefix = "RB_ENTRY_VIEW_", cheader_filename = "shell/rb-shell.h")]
	public enum EntryViewState {
		NOT_PLAYING,
		PLAYING,
		PAUSED
	}
	[CCode (cprefix = "RB_PLAYLIST_EXPORT_TYPE_", has_type_id = false, cheader_filename = "shell/rb-shell.h")]
	public enum PlaylistExportType {
		UNKNOWN,
		M3U,
		PLS,
		XSPF
	}
	[CCode (cprefix = "RB_PLAYLIST_MANAGER_ERROR_", has_type_id = false, cheader_filename = "shell/rb-shell.h")]
	public enum PlaylistManagerError {
		PARSE,
		PLAYLIST_EXISTS,
		PLAYLIST_NOT_FOUND
	}
	[CCode (cprefix = "RB_TREE_DEST_", has_type_id = false, cheader_filename = "shell/rb-shell.h")]
	public enum RbTreeDestFlag {
		EMPTY_VIEW_DROP,
		CAN_DROP_INTO,
		CAN_DROP_BETWEEN,
		SELECT_ON_DRAG_TIMEOUT
	}
	[CCode (cprefix = "RB_SHELL_PLAYER_ERROR_", cheader_filename = "shell/rb-shell.h")]
	public enum ShellPlayerError {
		PLAYLIST_PARSE_ERROR,
		END_OF_PLAYLIST,
		NOT_PLAYING,
		NOT_SEEKABLE,
		POSITION_NOT_AVAILABLE
	}
	[CCode (cprefix = "RB_SHELL_UI_LOCATION_", cheader_filename = "shell/rb-shell.h")]
	public enum ShellUILocation {
		SIDEBAR,
		RIGHT_SIDEBAR,
		MAIN_TOP,
		MAIN_BOTTOM,
		MAIN_NOTEBOOK
	}
	[CCode (cprefix = "RB_SOURCE_EOF_", cheader_filename = "shell/rb-shell.h")]
	public enum SourceEOFType {
		ERROR,
		STOP,
		RETRY,
		NEXT
	}
	[CCode (cprefix = "RB_SOURCE_GROUP_CATEGORY_", has_type_id = false, cheader_filename = "shell/rb-shell.h")]
	public enum SourceGroupCategory {
		FIXED,
		REMOVABLE,
		PERSISTENT,
		TRANSIENT,
		LAST
	}
	[CCode (cprefix = "RB_SOURCELIST_MODEL_COLUMN_", cheader_filename = "shell/rb-shell.h")]
	public enum SourceListModelColumn {
		PLAYING,
		PIXBUF,
		NAME,
		SOURCE,
		ATTRIBUTES,
		VISIBILITY,
		IS_GROUP,
		GROUP_CATEGORY
	}
	[CCode (cprefix = "RB_SOURCE_SEARCH_", cheader_filename = "shell/rb-shell.h")]
	public enum SourceSearchType {
		NONE,
		INCREMENTAL,
		EXPLICIT
	}
	[CCode (cprefix = "RB_SOURCE_GROUP_CATEGORY_", cheader_filename = "shell/rb-shell.h")]
	public enum SourcelistGroupType {
		FIXED,
		PERSISTENT,
		REMOVABLE,
		TRANSIENT
	}
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate bool BrowserSourceFeatureFunc (RB.BrowserSource source);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate unowned string BrowserSourceStringFunc (RB.BrowserSource source);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate bool PlayOrderQueryFunc (RB.PlayOrder porder);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate void PluginActivationFunc (RB.Plugin plugin, RB.Shell shell);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate bool PluginBooleanFunc (RB.Plugin plugin);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate unowned Gtk.Widget PluginWidgetFunc (RB.Plugin plugin);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate void SourceActionCallback (Gtk.Action action, RB.Source source);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate bool SourceFeatureFunc (RB.Source source);
	[CCode (cheader_filename = "shell/rb-shell.h", has_target = false)]
	public delegate unowned string SourceStringFunc (RB.Source source);
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public static unowned GLib.List get_plugin_paths ();
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public static void tree_dnd_add_drag_dest_support (Gtk.TreeView tree_view, RB.RbTreeDestFlag flags, Gtk.TargetEntry[] targets, Gdk.DragAction actions);
	[CCode (cheader_filename = "shell/rb-shell.h")]
	public static void tree_dnd_add_drag_source_support (Gtk.TreeView tree_view, Gdk.ModifierType start_button_mask, Gtk.TargetEntry[] targets, Gdk.DragAction actions);
}
