#!/usr/bin/env python
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#
#       Copyright 2009 Markus Korn <thekorn@gmx.de>
#

import sys
import time
import logging
import json
import urlparse

from optparse import OptionParser

def vararg_callback(option, opt_str, value, parser):
    assert value is None
    value = []

    def floatable(str):
        try:
            float(str)
            return True
        except ValueError:
            return False

    for arg in parser.rargs:
        # stop on --foo like options
        if arg[:2] == "--" and len(arg) > 2:
            break
        # stop on -a, but not on -3 or -3.0
        if arg[:1] == "-" and len(arg) > 1 and not floatable(arg):
            break
        value.append(arg)

    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)
    
def get_origin(uri):
    scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)
    origin = urlparse.urlunsplit((scheme, netloc, "", "", ""))
    return origin
    
def single_insert(location, title, tags=None):
    # lazy import to catch the error
    from zeitgeist.client import ZeitgeistClient
    from zeitgeist.datamodel import Event, Subject, Interpretation, Manifestation
        
    tags = tags or list()
    logging.debug("Zeitgeist extension for firefox is sending a visit event '%s'" %location)
    
    client = ZeitgeistClient()
    
    subject = Subject.new_for_values(
        uri=location.decode("UTF-8"),
        interpretation=unicode(Interpretation.UNKNOWN), #TBD?
        manifestation=unicode(Manifestation.WEB_HISTORY),
        origin=unicode(get_origin(location)),
        mimetype=u"text/html", #TBD
        text=title.decode("UTF-8"),
    )            
    event = Event.new_for_values(
        timestamp=int(time.time()*1000),
        interpretation=unicode(Interpretation.VISIT_EVENT),
        manifestation=unicode(Manifestation.USER_ACTIVITY),
        actor="application://firefox.desktop",
        subjects=[subject,]
    )
    client.insert_event(event)
    
def bulk(filename, tags=None):
    # lazy import to catch the error    
    from zeitgeist.client import ZeitgeistDBusInterface
    from zeitgeist.datamodel import Event, Subject, Interpretation, Manifestation
    
    tags = tags or list()
    arguments = list()
    content = open(filename).read().decode("UTF-8")
    data = json.loads(content.replace("\\", "\\\\"))
    
    iface = ZeitgeistDBusInterface()
    
    for entry in data["bulk"]:
        subject = Subject.new_for_values(
            uri=entry[1],
            interpretation=unicode(Interpretation.UNKNOWN), #TBD?
            manifestation=unicode(Manifestation.WEB_HISTORY),
            origin=unicode(get_origin(entry[1])),
            mimetype=u"text/html", #TBD
            text=entry[2],
        )            
        event = Event.new_for_values(
            timestamp=int(entry[0] // 1000),
            interpretation=unicode(Interpretation.VISIT_EVENT),
            manifestation=unicode(Manifestation.USER_ACTIVITY),
            actor="application://firefox.desktop",
            subjects=[subject,]
        )
    return iface.InsertEvents(arguments)
    
def getLastTimestamp(filename):
    # lazy import to catch the error
    from zeitgeist.client import ZeitgeistDBusInterface
    from zeitgeist.datamodel import Event, TimeRange, StorageState, ResultType
    
    iface = ZeitgeistDBusInterface()
    ev_template = Event.new_for_values(actor="application://firefox.desktop")
    events = iface.FindEventIds(
        TimeRange.until_now(), [ev_template,], StorageState.Any, 1, ResultType.MostRecentEvents)
    if events:
        event = Event(iface.GetEvents(events)[0])
        timestamp = int(event.timestamp)
    else:
        timestamp = 0
    print "LAST TIMESTAMP", timestamp
    f = open(filename, "w")
    f.write(str(timestamp))
    f.close()
    return 0
    
def parse_cmdline_args():
    parser = OptionParser()
    parser.add_option(
        "--location", dest="location", help="uri related to the event", metavar="URI", default=None,
    )
    parser.add_option(
        "--title", dest="title", help="title to the event", metavar="TITLE", default=None,
    )
    parser.add_option(
        "--bulk", dest="bulk", help="read events from --iofile and bulk-insert them", action="store_true"
    )
    parser.add_option(
        "--iofile", dest="iofile", help="file to communicate with the FF extension", metavar="FILENAME"
    )
    parser.add_option(
        "--last", dest="last",
        help="write the timestamp of the last inserted event to --iofile", action="store_true"
    )
    parser.add_option(
        "--tags", dest="tags", action="callback", callback=vararg_callback,
        help="tag to the event", metavar="TAG1 TAG2 ...", default=[],
    )
    return parser.parse_args()
    

def main():
    options, args = parse_cmdline_args()
    assert not args, args
    
    if options.bulk:
        #run bulk-upload
        assert options.iofile, " --iofile not given"
        return bulk(options.iofile, options.tags)
    elif options.last:
        assert options.iofile, " --iofile not given"
        return getLastTimestamp(options.iofile)
    elif options.location is not None and options.title is not None:
        return single_insert(options.location, options.title, options.tags)
    else:
        raise ValueError("wrong arguments")

if __name__ == "__main__":
    try:
        main()
    except RuntimeError, e:
        logging.error("Failed to send event to the zeitgeist engine: %s" %e)
        sys.exit(100)
    except:
        options, args = parse_cmdline_args()
        if options.iofile:
            import traceback
            traceback.print_exc(file=open(options.iofile, "w"))
        raise
    sys.exit(0)
    
